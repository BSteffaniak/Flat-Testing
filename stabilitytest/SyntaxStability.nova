package "stabilitytest"

import "nova/datastruct/list/Iterator"

class SyntaxStability extends StabilityTestCase {
    public construct(StabilityTest program) {
        super(program)
    }

    public test() {
        checkLoops()
        checkUntil()
        checkMatchStatements()
        checkIterators()
        checkTernary()
        checkElvis()
        // checkRepeat()
        checkNamedArguments()
        checkDefaultClosureArguments()
        checkZipper()
        checkSafeNavigation()
        checkSnakeCaseNumbers()
        checkArrayInitializers()
        checkFunctionReturnType()
    }

    checkMatchStatements() {
        Console.write("Checking simple match statement... ")

        Int  num    = 3
        Bool worked = false

        match (num) {
            1 => program.fail("Match accepted incorrect case")
            2 => program.fail("Match accepted incorrect case")
            3 => worked = true
            4 => program.fail("Match accepted incorrect case")
            default => program.fail("Match failed to accept the correct case")
        }

        program.fail("FAIL", !worked)

        Console.writeLine("OK")

        Console.write("Checking simple match statement with indentation... ")

        num    = 3
        worked = false

        switch (num)
            1 =>
                program.fail("Match accepted incorrect case")
            2 => program.fail("Match accepted incorrect case")
            3 =>
                worked = true
            4 =>
                program.fail("Match accepted incorrect case")
            default =>
                program.fail("Match failed to accept the correct case")
        
        program.fail("FAIL", !worked)

        Console.writeLine("OK")

        Console.write("Checking simple match statement with scopes... ")

        num    = 3
        worked = false

        match (num) {
            1 => {
                program.fail("Match accepted incorrect case")
            }
            2 => {
                program.fail("Match accepted incorrect case")
            }
            3 => {
                worked = true
            }
            4 => {
                program.fail("Match accepted incorrect case")
            }
            default => {
                program.fail("Match failed to accept the correct case")
            }
        }

        if (!worked) {
            program.fail("FAIL")
        }

        Console.writeLine("OK")

        Console.write("Checking match statement with variable case values... ")

        Int val = 1
        num     = 3
        worked  = false

        match (num) {
            val++ => {
                program.fail("Match accepted incorrect case")
            } val++ => {
                program.fail("Match accepted incorrect case")
            } (val++) => {
                worked = true
            }
            val++ => {
                program.fail("Match accepted incorrect case")
            } default => {
                program.fail("Match failed to accept the correct case")
            }
        }
        
        program.fail("FAIL", !worked)

        Console.writeLine("OK")

        Console.write("Checking match statement with variable case values and fallthrough... ")

        val    = 1
        num    = 3
        worked = false

        Bool worked2 = false

        match (num++) {
            val++ => {
                program.fail("Match accepted incorrect case")
            } val++ => {
                program.fail("Match accepted incorrect case")
            } val++ => {
                worked = true
                fallthrough
            } val++ => {
                worked2 = true
            } default => {
                program.fail("Match failed to accept the correct case")
            }
        }

        program.fail("FAIL", !worked || !worked2)

        Console.writeLine("OK")
    }

    checkLoops() {
        checkWhileLoops()
        checkForLoops()
    }

    checkWhileLoops() {
        Console.write("Checking inline while loop... ")

        Int num  = 0
        Int num2 = 0
        Int num3 = 0

        while (num < 100) num++

        while (num2 < 100)
            num2++

        while (num3 < 100)
            if (true)
                if (true) {
                    num3++
                }

        program.fail("Inline while loop failed.", num != 100 || num2 != 100 || num3 != 100)

        Console.writeLine("OK")
    }

    checkForLoops() {
        Console.write("Checking inline for loop... ")

        Int num  = 0
        Int num2 = 0
        Int num3 = 0

        for (i in 0..100) num++

        for (i2 in 0..100)
            num2++

        for (i3 in 0..100)
            if (true)
                if (true) {
                    num3++
                }

        program.fail("Inline for loop failed. Expected 100, 100, 100 received #{num}, #{num2}, #{num3}", num != 100 || num2 != 100 || num3 != 100)

        Console.writeLine("OK")
    }

    checkUntil() {
        Console.write("Checking until statement... ")

        Object obj

        until (obj) {
            obj = test1()
            obj = test2()
            obj = test3()

            program.fail("Failed to stop after correct condition")
        }

//        if (obj == null) {
//            obj = test1();
//            if (obj == null) {
//                obj = test2();
//                if (obj == null) {
//                    obj = test3();
//                    if (obj == null) {
//                        program.fail("Until statement failed");
//                    }
//                }
//            }
//        }

        program.fail("Failed to reach correct condition", obj == null)

        Console.writeLine("OK");
    }

    static test1() => null
    static test2() => null
    static test3() => new Object()
    
    static filterFunc(String i) -> Bool {
        return i.count >= 4
    }

    static foreachClosure(String s) {
        if (s.count < 4) {
            throw new UnstableException("filtering failed")
        }
    }

    checkIterators() {
        Console.write("Checking filter functionality... ")

        String[] list = ["this", "is", "a", "test", "to", "see", "what shows up"]
        String[] list2 = list.filter(filterFunc)

        try {
            list2.forEach(foreachClosure)
        } catch (UnstableException e) {
            program.fail("Failed to filter data correctly")
        }

        for (n in 0..list2.count) {
            program.fail("Failed to filter data correctly", list2[n].count < 4)
        }

        /*if (list2.any(x -> x.count < 4)) {
            program.fail("Failed to filter data correctly")
        }
        if (!list2.all(x -> x.count >= 4)) {
            program.fail("Failed to filter data correctly")
        }*/

        Console.writeLine("OK")

        Console.write("Checking iterator functionality... ")

        Iterator<String> iter = list2.iterator

        while (iter.hasNext) {
            program.fail("Failed to run iterator", iter.next.count < 4)
        }

        Console.writeLine("OK")

        Console.write("Checking foreach loop functionality... ")

        for (string in list2) {
            program.fail("Failed to run foreach loop", string.count < 4)
        }

        Console.writeLine("OK")
    }

    checkTernary() {
        Console.write("Checking ternary functionality... ")

        var first = trueValue() ? "hey" == "hey" : "hey" == "hey2"

        program.fail("Failed first ternary test", !first)

        var second = falseValue() ? "one" : "two"

        program.fail("Failed second ternary test", second != "two")

        Console.writeLine("OK")
    }

    checkElvis() {
        Console.write("Checking elvis functionality... ")

        var str = "this isnt null"
        String str2 = null

        var result1 = str ?: "wtf"

        program.fail("Failed first elvis test", result1 == "wtf")

        var result2 = str2 ?: "this is null"

        program.fail("Failed second elvis test", result2 != "this is null")

        Console.writeLine("OK")
    }

    trueValue() -> Bool {
        return true
    }

    falseValue() -> Bool {
        return false
    }

    // checkRepeat() {
    //     Console.write("Checking repeat functionality... ")

    //     Int i = 0

    //     repeat {
    //         if (i == 101) {
    //             break
    //         }

    //         i++
    //     }
        
    //     program.fail("Vanilla repeat failed", i != 101)

    //     i = 0

    //     repeat (101) {
    //         i++
    //     }

    //     program.fail("Repeat 101 times failed", i != 101)

    //     i = 0

    //     Int times = 101

    //     repeat (times) {
    //         i++
    //     }

    //     program.fail("Repeat times (#times) failed", i != 101)

    //     i = 0

    //     repeat (times) i++

    //     program.fail("Repeat fragment failed", i != 101)

    //     Console.writeLine("OK")
    // }

    named(String s, String arg, Int jum = 4, Int jdd = 0, Int joe = 0) -> Int {
        return -1
    }

    named(String s, String arg, Int num = 4, Int add = 0) -> Int {
        return num * arg.count + add
    }

    checkNamedArguments() {
        Console.write("Checking named arguments... ")

        var num = named("", arg: "yo", num: 4)

        program.fail("Default argument failed. Expected 8, received #num", num != 8)

        num = named("", add: 2, arg: "heyasdf", num: 5)

        program.fail("Named arguments failed. Expeced 37, received #num first", num != 37)

        num = named(add: 2, num: 5, arg: "heyasdf", s: "")

        program.fail("Named arguments failed. Expeced 37, received #num second", num != 37)

        Console.writeLine("OK")
    }
    
    func1(Int a) -> Int => a * 2
    func2(Int a) -> Int => a * 4
    
    myFunc(something(Int) -> Int = func2) => something(5)
    
    checkDefaultClosureArguments() {
    	Console.write("Checking default closure arguments... ")
    	
    	program.fail("Failed to call default closure", myFunc() != 20)
    	program.fail("Failed to call overrided default closure", myFunc(func1) != 10)
    	
    	Console.writeLine("OK")
    }

    checkZipper() { // lol
        Console.write("Checking zip function... ")

        var array1 = ["This", "is", "a", "test"]
        var array2 = ["one", "two", "three", "four"]//[1, 2, 4, 3]

        var zipped = array1.zip(array2, (x, y) => "#x #y")
        Console.write("Zipped: #zipped ")
        
        Console.writeLine("OK")
    }

    checkSafeNavigation() {
        Console.write("Checking safe navigation operator... ")
        
        var node = new Node()
        node.value = 1
        
        node.child = new Node()
        node.child.value = 2
        
        node.child.child = new Node()
        node.child.child.value = 3
        
        Console.write("if statement... ")
        
        if (node?.child?.child?.value == 3 && node?.child?.value == 2 && node?.value == 1) {
            Console.write("assignment... ")
            
            node?.child?.child.value = 5
            
            program.fail("Failed to set node value while safely navigating it", node?.child?.child.value != 5)
            
            node.child.child = null
            
            program.fail("Failed to skip null child", node?.child?.child?.value == 3)
            
            node.child.child = new Node()
            node.child.child.child = new Node()
            node.child.child.child.child = new Node()
            node.child.child.child.child.value = 91
            
            Console.write("function call... ")
            callMeWithNode(node?.child?.child?.child?.child)
            
            var array = ["1", "2", "3", "4", "5"]
            
            Console.write("array access... ")
            array[node?.child?.value] = "hello"
            
            program.fail("Failed to set correct array index with correct value using the safe navigation operator", array[2] != "hello")
        } else {
            program.fail("Failed to safely navigate valid children")
        }
        
        Console.writeLine("OK")
    }
    
    checkArraySafeNavigation() {
    	Console.write("Checking array safe navigaiton... ")
    	
    	/*var myArray = [0, 1, 2, 3, 4, 5, 6]
    	
    	program.fail("Failed to access valid index with safe navigation", myArray?[4] != 4)
    	*/
    	Console.writeLine("OK")
    }
    
    callMeWithNode(Node n) => program.fail("Failed to call method with correct safely navigated node", n.value != 91)
    
    checkSnakeCaseNumbers() {
    	Console.write("Checking snake case numbers... ")
    	
    	Double dPos =  51_325_753.131313
    	Double dNeg = -51_325_753.131313
    	
    	program.fail("Positive snake case double failed to parse", dPos !=  51325753.131313)
    	program.fail("Negative snake case double failed to parse", dNeg != -51325753.131313)
    	
    	Long lPos =  922_547_211
    	Long lNeg = -922_547_211
    	
    	program.fail("Negative snake case long failed to parse", lPos !=  922547211)
    	program.fail("Negative snake case long failed to parse", lNeg != -922547211)
    	
    	Console.writeLine("OK")
    }
    
    checkArrayInitializers() {
    	Console.write("Checking array initializers... ")
    	
    	Int num1 = 1
    	Int num2 = 2
    	
    	var myInts = [0, 0, num1, num2, 0]
    	
    	program.fail("Failed to ", myInts[2] != num1 || myInts[3] != num2)
    	
    	Console.writeLine("OK")
    }
    
    Bool funcSwitch = false
    Int funcCount, chainCount
    
    checkFunctionReturnType() {
        Console.write("Checking calling a function returned by a function... ")
        
        let func = getFunc()
        
        func()
        
        program.fail("Failed to call first class function returned from function", !funcSwitch)
        
        Console.writeLine("OK")
        
        funcSwitch = false
        
        Console.write("Checking calling a function returned by an inline function... ")
        
        let func2 = inlineGetFunc()
        
        func2()
        
        program.fail("Failed to call first class function returned from inline function", !funcSwitch)
        
        Console.writeLine("OK")
        
        funcSwitch = false
        
        Console.write("Checking calling a function returned by an inline function with type specified... ")
        
        let func3 = inlineGetFunc2()
        
        func3()
        
        program.fail("Failed to call first class function returned from inline function with type specified", !funcSwitch)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        
        Console.write("Checking calling a chained function returned by a function... ")
        
        let chained = chainedFuncReference()
        
        chained()()
        
        program.fail("Failed to call first class chained function returned from function: #funcSwitch, #funcCount", !funcSwitch || funcCount != 1)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        
        Console.write("Checking calling an assigned chained function returned by a function... ")
        
        let c = chained()
        c()
        c()
        c()
        
        program.fail("Failed to call first class chained function returned from function: #funcSwitch, #funcCount", !funcSwitch || funcCount != 3)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        Console.write("Checking calling a chained function x3 returned by a function... ")
        
        let chainX3 = chainedFuncReference3()
        
        chainX3()()()
        
        program.fail("Failed to call first class chained function x3 returned from function: #funcSwitch, #funcCount, x#chainCount", !funcSwitch || funcCount != 1 || chainCount != 3)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        Console.write("Checking calling a chained function x4 returned by a function... ")
        
        let chainX4 = chainedFuncReference4()
        
        chainX4()()()()
        
        program.fail("Failed to call first class chained function x4 returned from function: #funcSwitch, #funcCount, x#chainCount", !funcSwitch || funcCount != 1 || chainCount != 4)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        Console.write("Checking calling a chained function x5 returned by a function... ")
        
        let chainX5 = chainedFuncReference5()
        
        chainX5()()()()()
        
        program.fail("Failed to call first class chained function x5 returned from function: #funcSwitch, #funcCount, x#chainCount", !funcSwitch || funcCount != 1 || chainCount != 5)
        
        Console.writeLine("OK")
        
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        Console.write("Checking calling a chained function x6 returned by a function... ")
        
        let chainX6 = chainedFuncReference6()
        
        chainX6()()()()()()
        
        program.fail("Failed to call first class chained function x6 returned from function: #funcSwitch, #funcCount, x#chainCount", !funcSwitch || funcCount != 1 || chainCount != 6)
        
        Console.writeLine("OK")
    }
    
    refFunc() {
        funcSwitch = true
        funcCount++
    }
    
    getFunc() -> func() {
        return refFunc
    }
    
    inlineGetFunc() => refFunc { chainCount++ }
    
    inlineGetFunc2() -> f() => refFunc
    
    chainedFuncReference() => inlineGetFunc { chainCount++ }
    chainedFuncReference3() => chainedFuncReference { chainCount++ }
    chainedFuncReference4() => chainedFuncReference3 { chainCount++ }
    chainedFuncReference5() => chainedFuncReference4 { chainCount++ }
    chainedFuncReference6() => chainedFuncReference5 { chainCount++ }
}