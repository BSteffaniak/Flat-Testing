package "stabilitytest"

import "nova/datastruct/list/Iterator"

import "novex/nest/Nest"
import "novex/nest/TestSuite"

import static "novex/nest/Nest"

testable class SyntaxStability {
    [Test "Testing simple match statement"]
    testSimpleMatchStatement() {
        Int  num    = 3
        Bool worked = false

        match (num) {
            1 => fail("Match accepted incorrect case")
            2 => fail("Match accepted incorrect case")
            3 => worked = true
            4 => fail("Match accepted incorrect case")
            default => fail("Match failed to accept the correct case")
        }

        expectTrue(worked, "FAIL")
    }

    [Test "Testing simple match statement with indentation"]
    testSimpleMatchStatementWithIndentation() {
        Int  num    = 3
        Bool worked = false

        switch (num)
            1 =>
                fail("Match accepted incorrect case")
            2 => fail("Match accepted incorrect case")
            3 =>
                worked = true
            4 =>
                fail("Match accepted incorrect case")
            default =>
                fail("Match failed to accept the correct case")
        
        expectTrue(worked, "FAIL")
    }
    
    [Test "Testing simple match statement with scopes"]
    testSimpleMatchStatementWithScopes() {
        Int  num    = 3
        Bool worked = false

        match (num) {
            1 => {
                fail("Match accepted incorrect case")
            }
            2 => {
                fail("Match accepted incorrect case")
            }
            3 => {
                worked = true
            }
            4 => {
                fail("Match accepted incorrect case")
            }
            default => {
                fail("Match failed to accept the correct case")
            }
        }

        expectTrue(worked, "FAIL")
    }
    
    [Test "Testing match statement with variable case values"]
    testMatchStatementWithVariableCaseValues() {
        Int  val    = 1
        Int  num    = 3
        Bool worked = false

        match (num) {
            val++ => {
                fail("Match accepted incorrect case")
            } val++ => {
                fail("Match accepted incorrect case")
            } (val++) => {
                worked = true
            }
            val++ => {
                fail("Match accepted incorrect case")
            } default => {
                fail("Match failed to accept the correct case")
            }
        }
        
        expectTrue(worked, "FAIL")
    }
    
    [Test "Testing match statement with variable case values and fallthrough"]
    testMatchStatementWithVariableCaseValuesAndFallthrough() {
        Int  val    = 1
        Int  num    = 3
        Bool worked = false

        Bool worked2 = false

        match (num++) {
            val++ => {
                fail("Match accepted incorrect case")
            } val++ => {
                fail("Match accepted incorrect case")
            } val++ => {
                worked = true
                fallthrough
            } val++ => {
                worked2 = true
            } default => {
                fail("Match failed to accept the correct case")
            }
        }

        expectTrue(worked && worked2, "FAIL")
    }
    
    [Test "Testing inline while loop"]
    testWhileLoops() {
        Int num  = 0
        Int num2 = 0
        Int num3 = 0

        while (num < 100) num++

        while (num2 < 100)
            num2++

        while (num3 < 100)
            if (true)
                if (true) {
                    num3++
                }

        expectTrue(num == 100 && num2 == 100 && num3 == 100, "Inline while loop failed.")
    }
    
    [Test "Testing inline for loop"]
    testForLoops() {
        Int num  = 0
        Int num2 = 0
        Int num3 = 0

        for (i in 0..100) num++

        for (i2 in 0..100)
            num2++

        for (i3 in 0..100)
            if (true)
                if (true) {
                    num3++
                }

        expectTrue(num == 100 && num2 == 100 && num3 == 100, "Inline for loop failed. Expected 100, 100, 100 received #{num}, #{num2}, #{num3}")
    }
    
    [Test "Testing until statement"]
    testUntil() {
        Object obj

        until (obj) {
            obj = test1()
            obj = test2()
            obj = test3()

            fail("Failed to stop after correct condition")
        }

//        if (obj == null) {
//            obj = test1();
//            if (obj == null) {
//                obj = test2();
//                if (obj == null) {
//                    obj = test3();
//                    if (obj == null) {
//                        program.fail("Until statement failed");
//                    }
//                }
//            }
//        }

        expectFalse(obj == null, "Failed to reach correct condition")
    }

    static test1() => null
    static test2() => null
    static test3() => new Object()
    
    static filterFunc(String i) -> Bool {
        return i.count >= 4
    }

    static foreachClosure(String s) {
        if (s.count < 4) {
            throw new UnstableException("filtering failed")
        }
    }
    
    [Test "Testing filter functionality"]
    testFilterFunctionality() {
        String[] list = ["this", "is", "a", "test", "to", "see", "what shows up"]
        String[] list2 = list.filter(filterFunc)
        
        try {
            list2.forEach(foreachClosure)
        } catch (UnstableException e) {
            fail("Failed to filter data correctly")
        }

        for (n in 0..list2.count) {
            expectTrue(list2[n].count >= 4, "Failed to filter data correctly")
        }

        /*if (list2.any(x -> x.count < 4)) {
            program.fail("Failed to filter data correctly")
        }
        if (!list2.all(x -> x.count >= 4)) {
            program.fail("Failed to filter data correctly")
        }*/
    }
    
    [Test "Testing iterator functionality"]
    testIteratorFunctionality() {
        String[] list = ["this", "is", "a", "test", "to", "see", "what shows up"]
        String[] list2 = list.filter(filterFunc)
        
        Iterator<String> iter = list2.iterator
        
        while (iter.hasNext) {
            expectTrue(iter.next.count >= 4, "Failed to run iterator")
        }
    }
    
    [Test "Testing foreach loop functionality"]
    testForeachLoopFunctionality() {
        String[] list = ["this", "is", "a", "test", "to", "see", "what shows up"]
        String[] list2 = list.filter(filterFunc)
        
        for (string in list2) {
            expectTrue(string.count >= 4, "Failed to run foreach loop")
        }
    }

    [Test "Testing ternary functionality"]
    testTernary() {
        var first = trueValue() ? "hey" == "hey" : "hey" == "hey2"

        expectTrue(first, "Failed first ternary test")

        var second = falseValue() ? "one" : "two"

        expectTrue(second == "two", "Failed second ternary test")
    }

    [Test "Testing elvis functionality"]
    testElvis() {
        var str = "this isnt null"
        String str2 = null

        var result1 = str ?: "wtf"

        expectFalse(result1 == "wtf", "Failed first elvis test")

        var result2 = str2 ?: "this is null"

        expectTrue(result2 == "this is null", "Failed second elvis test")
    }

    trueValue() -> Bool {
        return true
    }

    falseValue() -> Bool {
        return false
    }

    // checkRepeat() {
    //     out.write("Checking repeat functionality... ")

    //     Int i = 0

    //     repeat {
    //         if (i == 101) {
    //             break
    //         }

    //         i++
    //     }
        
    //     program.fail("Vanilla repeat failed", i != 101)

    //     i = 0

    //     repeat (101) {
    //         i++
    //     }

    //     program.fail("Repeat 101 times failed", i != 101)

    //     i = 0

    //     Int times = 101

    //     repeat (times) {
    //         i++
    //     }

    //     program.fail("Repeat times (#times) failed", i != 101)

    //     i = 0

    //     repeat (times) i++

    //     program.fail("Repeat fragment failed", i != 101)

    //     out.write("OK\n")
    // }

    named(String s, String arg, Int jum = 4, Int jdd = 0, Int joe = 0) -> Int {
        return -1
    }

    named(String s, String arg, Int num = 4, Int add = 0) -> Int {
        return num * arg.count + add
    }
    
    [Test "Testing named arguments"]
    testNamedArguments() {
        var num = named("", arg: "yo", num: 4)
        
        expectTrue(num == 8, "Default argument failed. Expected 8, received #num")
        
        num = named("", add: 2, arg: "heyasdf", num: 5)
        
        expectTrue(num == 37, "Named arguments failed. Expeced 37, received #num first")
        
        num = named(add: 2, num: 5, arg: "heyasdf", s: "")
        
        expectTrue(num == 37, "Named arguments failed. Expeced 37, received #num second")
    }
    
    func1(Int a) -> Int => a * 2
    func2(Int a) -> Int => a * 4
    
    myFunc(something(Int) -> Int = func2) => something(5)
    
    [Test "Testing default closure arguments"]
    checkDefaultClosureArguments() {
    	expectTrue(myFunc() == 20, "Failed to call default closure")
    	expectTrue(myFunc(func1) == 10, "Failed to call overrided default closure")
    }
    
    [Test "Testing zip function"]
    checkZipper() { // lol
        var array1 = ["This", "is", "a", "test"]
        var array2 = ["one", "two", "three", "four"]//[1, 2, 4, 3]

        var zipped = array1.zip(array2, (x, y) => "#x #y")
        out.write("Zipped: #zipped ")
    }
    
    [Test "Testing safe navigation operator"]
    testSafeNavigation() {
        var node = new Node()
        node.value = 1
        
        node.child = new Node()
        node.child.value = 2
        
        node.child.child = new Node()
        node.child.child.value = 3
        
        out.write("if statement... ")
        
        if (node?.child?.child?.value == 3 && node?.child?.value == 2 && node?.value == 1) {
            out.write("assignment... ")
            
            node?.child?.child.value = 5
            
            expectTrue(node?.child?.child.value == 5, "Failed to set node value while safely navigating it")
            
            node.child.child = null
            
            expectFalse(node?.child?.child?.value == 3, "Failed to skip null child")
            
            node.child.child = new Node()
            node.child.child.child = new Node()
            node.child.child.child.child = new Node()
            node.child.child.child.child.value = 91
            
            out.write("function call... ")
            callMeWithNode(node?.child?.child?.child?.child)
            
            var array = ["1", "2", "3", "4", "5"]
            
            out.write("array access... ")
            array[node?.child?.value] = "hello"
            
            expectTrue(array[2] == "hello", "Failed to set correct array index with correct value using the safe navigation operator")
        } else {
            fail("Failed to safely navigate valid children")
        }
    }
    
    [Test "Testing array safe navigation"]
    testArraySafeNavigation() {
    	/*var myArray = [0, 1, 2, 3, 4, 5, 6]
    	
    	program.fail("Failed to access valid index with safe navigation", myArray?[4] != 4)
    	*/
    }
    
    callMeWithNode(Node n) => expectTrue(n.value == 91, "Failed to call method with correct safely navigated node")
    
    [Test "Testing snake case numbers"]
    testSnakeCaseNumbers() {
    	Double dPos =  51_325_753.131313
    	Double dNeg = -51_325_753.131313
    	
    	expectTrue(dPos ==  51325753.131313, "Positive snake case double failed to parse")
    	expectTrue(dNeg == -51325753.131313, "Negative snake case double failed to parse")
    	
    	Long lPos =  922_547_211
    	Long lNeg = -922_547_211
    	
    	expectTrue(lPos ==  922547211, "Negative snake case long failed to parse")
    	expectTrue(lNeg == -922547211, "Negative snake case long failed to parse")
    }
    
    [Test "Testing array initializers"]
    testArrayInitializers() {
    	Int num1 = 1
    	Int num2 = 2
    	
    	var myInts = [0, 0, num1, num2, 0]
    	
    	expectTrue(myInts[2] == num1 && myInts[3] == num2, "Failed to ")
    }
    
    Bool funcSwitch = false
    Int funcCount, chainCount
    
    [Test "Testing calling a function returned by a function"]
    testFunctionReturnedByFunction() {
        let func = getFunc()
        
        func()
        
        expectTrue(funcSwitch, "Failed to call first class function returned from function")
    }
    
    [Test "Testing calling a function returned by an inline function"]
    testFunctionReturnedByInlineFunction() {
        funcSwitch = false
        
        let func2 = inlineGetFunc()
        
        func2()
        
        expectTrue(funcSwitch, "Failed to call first class function returned from inline function")
    }
    
    [Test "Testing calling a function returned by an inline function with type specified"]
    testFunctionReturnedByInlineFunctionWithTypeSpecified() {
        funcSwitch = false
        
        let func3 = inlineGetFunc2()
        
        func3()
        
        expectTrue(funcSwitch, "Failed to call first class function returned from inline function with type specified")
    }
    
    [Test "Testing calling a chained function returned by a function"]
    testCallingChainedFunctionReturnedByFunction() {
        funcCount = 0
        funcSwitch = false
        
        let chained = chainedFuncReference()
        
        chained()()
        
        expectTrue(funcSwitch && funcCount == 1, "Failed to call first class chained function returned from function: #funcSwitch, #funcCount")
    }
    
    [Test "Testing calling an assigned chained function returned by a function"]
    testCallingAssignedChainFunction() {
        funcCount = 0
        funcSwitch = false
        
        let chained = chainedFuncReference()
        
        let c = chained()
        c()
        c()
        c()
        
        expectTrue(funcSwitch && funcCount == 3, "Failed to call first class chained function returned from function: #funcSwitch, #funcCount")
    }
    
    [Test "Testing calling a chained function x3 returned by a function"]
    testCallingChainedFunctionX3() {
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        let chainX3 = chainedFuncReference3()
        
        chainX3()()()
        
        expectTrue(funcSwitch && funcCount == 1 && chainCount == 3, "Failed to call first class chained function x3 returned from function: #funcSwitch, #funcCount, x#chainCount")
    }
    
    [Test "Testing calling a chained function x4 returned by a function"]
    testCallingChainedFunctionX4() {
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        let chainX4 = chainedFuncReference4()
        
        chainX4()()()()
        
        expectTrue(funcSwitch && funcCount == 1 && chainCount == 4, "Failed to call first class chained function x4 returned from function: #funcSwitch, #funcCount, x#chainCount")
    }
    
    [Test "Testing calling a chained function x5 returned by a function"]
    testCallingChainedFunctionX5() {
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        let chainX5 = chainedFuncReference5()
        
        chainX5()()()()()
        
        expectTrue(funcSwitch && funcCount == 1 && chainCount == 5, "Failed to call first class chained function x5 returned from function: #funcSwitch, #funcCount, x#chainCount")
    }
    
    [Test "Testing calling a chained function x6 returned by a function"]
    testCallingChainedFunctionX6() {
        funcCount = 0
        funcSwitch = false
        chainCount = 0
        
        let chainX6 = chainedFuncReference6()
        
        chainX6()()()()()()
        
        expectTrue(funcSwitch && funcCount == 1 && chainCount == 6, "Failed to call first class chained function x6 returned from function: #funcSwitch, #funcCount, x#chainCount")
    }
    
    refFunc() {
        funcSwitch = true
        funcCount++
    }
    
    getFunc() -> func() {
        return refFunc
    }
    
    inlineGetFunc() => refFunc { chainCount++ }
    
    inlineGetFunc2() -> f() => refFunc
    
    chainedFuncReference() => inlineGetFunc { chainCount++ }
    chainedFuncReference3() => chainedFuncReference { chainCount++ }
    chainedFuncReference4() => chainedFuncReference3 { chainCount++ }
    chainedFuncReference5() => chainedFuncReference4 { chainCount++ }
    chainedFuncReference6() => chainedFuncReference5 { chainCount++ }
    
    [Test "Testing single function in Array"]
    testSingleFunctionInArray() {
        let array = new Array<func()>()
        
        array.add(refFunc)
    }
    
    [Test "Testing calling a single function from Array"]
    testCallingFunctionFromCollection() {
        let array = new Array<func()>()
        
        array.add(refFunc)
        
        funcSwitch = false
        
        // array.first()
        
        // program.fail("Failed to call single function from collection", !funcSwitch)
    }
}