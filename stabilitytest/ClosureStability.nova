package "stabilitytest"

class ClosureStability extends StabilityTestCase {
    static Double TOLERANCE
    
    Int    number
    
    public construct(StabilityTest program) {
        super(program)
    }
    
    incrementNumber() {
        number++
    }
    
    public test() {
        TOLERANCE = 0.0000000001
        
        testClosures()
    }
    
    testClosures() {
        Console.writeLine("Checking closures...")
        
        testMathClosures()
        testInstanceClosure()
    }
    
    testMathClosures() {
        Console.write("Checking static math closures... ")
        
        Int a = 5
        Int b = 3
        
        Double value = 0.5
        
        program.fail("Failed to call multiply(Int, Int) closure", callClosure(multiply, a, b) != multiply(a, b))
        program.fail("Failed to call pow(Int, Int) closure", callClosure(pow, a, b) != pow(a, b))
        
        program.fail("Failed to call Math.sin(Double) closure", mathClosure(Math.sin, value) - Math.sin(value) >= TOLERANCE)
        program.fail("Failed to call Math.tan(Double) closure", mathClosure(Math.tan, value) - Math.tan(value) >= TOLERANCE)
        
        Console.writeLine("OK")
    }
    
    testInstanceClosure() {
        Console.write("Checking instance closures... ")
        
        ClosureStability c = new ClosureStability(program)
        
        instanceClosure(c.incrementNumber)
        
        program.fail("Failed to call incrementNumber() instance closure", c.number == 0)
        
        instanceClosure(new ClosureStability(program).incrementNumber)
        instanceClosure(c.incrementNumber)
        
        Console.writeLine("OK")
    }
    
    static callClosure(closure(Int, Int) -> Int, Int a, Int b) => closure(a, b)
    static mathClosure(closure(Double) -> Double, Double value) => closure(value)
    static instanceClosure(closure()) => closure()
    static multiply(Int value1, Int value2) => value1 * value2
    
    static pow(Int base, Int pow) -> Int {
        Int value = base
        
        for (i in 0..(pow - 1)) {
            value *= base
        }
        
        return value
    }
}